"""
Script to run MKVToolNix mux command in batch
"""

import os
import re
import glob
import mimetypes
import subprocess

# Most sytems don't have the font mime type mappings by default
# https://www.iana.org/assignments/media-types/media-types.xhtml#font
mimetypes.add_type('font/collection', '.collection')
mimetypes.add_type('font/otf', '.otf')
mimetypes.add_type('font/sfnt', '.sfnt')
mimetypes.add_type('font/ttf', '.ttf')
mimetypes.add_type('font/woff', '.woff')
mimetypes.add_type('font/woff2', '.woff2')


def find_adjacent_files(input_file: str) -> list[str]:
    """ Get a list of all files in the directory of input_file
        that have the same file extension as input_file
    """
    directory = os.path.dirname(input_file)
    extension = os.path.splitext(input_file)[1]
    search_regex = f"{glob.escape(directory)}{os.path.sep}*{extension}"
    return glob.glob(search_regex)


def list_directory(directory: str) -> list[str]:
    """ Retrieve list of all files & folders in directory """
    return [os.path.join(directory, file) for file in os.listdir(directory)]


def list_folders(directory: str) -> list[str]:
    """ Retrieve list of all folders in directory """
    return [os.path.join(directory, name) for name in os.listdir(directory) if
            os.path.isdir(os.path.join(directory, name))]


class InputCountException(Exception):
    """ Exception raised when the number of available files in the directory
                of one input file does not match with the number of availabile files
                of the other input files. Also used for attachments, chapters, etc.

    Attributes:
        file_count (int): number of files found in directory
        expected_file_count (int): expected number of files to be found in directory
    """

    def __init__(self, file_count: int, expected_file_count: int,
                 message: str = "Number of input files does not correspond to each other"):
        self.file_count = file_count
        self.expected_file_count = expected_file_count
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return f"Got {self.file_count} instead of {self.expected_file_count} -> {self.message}"


class FileAttachment:
    """ Class for defining an attachment in the final output file (i.e. fonts in MKV file)

    Properties:
        attachment_file (str): Full path to attachment file
        attachment_name (str): Name of the file (including extension)
        attachment_mime_type (str): Mime type of the file
    """

    def __init__(self, file: str) -> None:
        self.file = file
        self.name = os.path.basename(file)
        self.mime_type = mimetypes.guess_type(file)[0]

    def command_list(self) -> list[str]:
        """ Generates a list that can be part of MKVToolNix json format """
        return ["--attachment-name", self.name,
                "--attachment-mime-type", self.mime_type,
                "--attach-file", self.file]


class InputFile:
    """ Class for keeping track of the input files of a mkvtoolnix command.

    Properties:
        original_file (str): Absolute path of original file of the given command
        directory_files (list[str]): List of absolute paths of all files
                                    that are in the same directory as the
                                    original_file and have the same extension.
    """

    def __init__(self, original_file: str, toolnix_index: int) -> None:
        self.toolnix_index = toolnix_index
        self.original_file = original_file
        self.directory_files = find_adjacent_files(original_file)


class BatchMuxer:
    """ Class for muxing multiple files by analyzing a single mux command from MKVToolNix

    Properties:
        mkvtoolnix_options (list[str]): Original list of strings generated by MKVToolNix
        input_files (list[Inputfile]): List of all input files that will be used in batch muxing
        output_commands (list[str]): List of all final muxing commands
    """

    def __init__(self, mkvtoolnix_options: list, output_format: str = None) -> None:
        self.load(mkvtoolnix_options, output_format)

    def load(self, mkvtoolnix_options: list, output_format: str = None) -> None:
        """ Initializer that can be called through __init__ or directly for a new batch mux """
        self.mkvtoolnix_options = mkvtoolnix_options
        self.output_format = output_format
        self.input_files = self.__get_input_files()
        self.file_count = self.__check_file_count()
        self.output_commands = self.__generate_output_commands()

    def __get_mkvtoolnix_options_value(self, arg: str) -> str:
        """ Retrieves argument values from the mkvtoolnix options list """
        index = self.mkvtoolnix_options.index(arg) + 1
        value = self.mkvtoolnix_options[index]
        # Some options (such as --no-attachments) do not have a set string value
        # In those cases we simply return a boolean wether the argument exists or not
        return value if not value.startswith("--") else arg in self.mkvtoolnix_options

    def __get_input_files(self):
        """ For every input file in the MKVToolNix command, we
            create an InputFile object which scans the directory
            of the input file for all the files we want to mux
        """
        input_files = list()
        prev_value = ""
        for index, value in enumerate(self.mkvtoolnix_options):
            if index != 0 and prev_value == "(":
                input_files.append(InputFile(value, index))
            prev_value = value
        return input_files

    def __check_file_count(self) -> int:
        """ Checks if the amount of files in every input directory is the
            same, else we may end up with a bad mux or out of index error.
            Abort by throwing an exception and let the user fix the issue.

        Returns integer count of input files (which is equals the number of muxes to execute)
        """
        count = None
        for input_file in self.input_files:
            number_of_files = len(input_file.directory_files)
            if not count:
                count = number_of_files
            elif number_of_files != count:
                raise InputCountException(number_of_files, count)
        return count

    def __generate_output_filename(self, file_number: int) -> str:
        """ Generates the name of the output file based on the paramaters
            provided by the user.

        Attributes:
            file_number (int): Index number of file in its directory

        Returns a filename + extension
        """

        decimal_count = len(str(self.file_count))

        if self.output_format:
            output = self.output_format[:]
            # Number directly after %i indicates number length (e.g. %I2 will give 01, %I3 001)
            # Without a number uses automatic detection based on number of files
            # Index number can be done with offset, indicated by +NUMBER, e.g. +2
            index_matches = re.findall('(%I)([1-9])*(+[0-9][0-9]*)?', output)

            if output.startswith("%F"):
                # Using the filename of one of the input files
                match = re.search('(%F)([0-9][0-9]*)', output)
                output = os.path.basename(self.input_files[int(
                    match.group(2))].directory_files[file_number])
            elif index_matches is not None:
                # Using a template with provided number format
                for match in sorted(index_matches, key=lambda x: len(''.join(x)), reverse=True):
                    replace_str = match[0]
                    output_number = file_number
                    if match[1]:
                        replace_str += match[1]
                        decimal_count = match[1]
                    if match[2]:
                        replace_str += match[2]
                        output_number += int(match[2][1:])
                    output = output.replace(replace_str, str(
                        output_number).zfill(int(decimal_count)))
            else:
                # Using a static string without any provided unique identifier.
                # Append a number to prevent overwrites.
                try:
                    splitname = os.path.splitext(output)
                    output = f"{splitname[0]} ({file_number + 1}){splitname[1]}"
                except IndexError:
                    # In case the user forgot to provide a file extension, we detect
                    # the output file extension from the original MKVToolNix command.
                    output_extension = os.path.splitext(
                        self.__get_mkvtoolnix_options_value("--output"))[1]
                    output = f"{output} ({file_number + 1}){output_extension}"
            return output
        else:
            output_extension = os.path.splitext(
                self.__get_mkvtoolnix_options_value("--output"))[1]
            return str(file_number + 1).zfill(decimal_count) + output_extension

    def __generate_output_commands(self) -> list[str]:
        """ Generate the batch MKVToolNix commands """
        output_commands = []

        for i in range(self.file_count):
            # Copy the original MKVToolNix command
            command = self.mkvtoolnix_options[:]

            # Remove episode title so it uses the
            # title of the first given input file
            try:
                title_index = command.index("--title")
                del command[title_index:title_index+2]
            except ValueError:
                pass

            # Replace original input files to the
            # files wanted for each mux
            for input_file in self.input_files:
                command[input_file.toolnix_index] = input_file.directory_files[i]

            # Set output file
            output_index = command.index("--output") + 1
            command[output_index] = self.__generate_output_filename(i)

            output_commands.append(command)

        return output_commands

    def __purge_attachments(self, command: str) -> None:
        """ Purges all attachments from a MKVToolNix command """
        indexes_to_delete = []
        for index, attribute in enumerate(command):
            if attribute.startswith("--attach"):
                indexes_to_delete.extend((index, index + 1))

        # We start at the highest index so the other indexes in
        # indexes_to_delete won't delete the wrong value or raise
        # an out of index exception
        indexes_to_delete.sort(reverse=True)
        for index in indexes_to_delete:
            del command[index]

    def load_attachments_per_folder(self, attachments_folder: str) -> None:
        """ In some cases you want to use a separate set of
            attachments per mux, e.g. not every episode
            needs the same fonts. Here we assume the user has
            an attachments folder that contains several folders
            each with their own set of attachments within it.
        """
        attachment_folders = list_folders(attachments_folder)

        # If the number of attachment folders does not correspond to the number input
        # files, we raise an exception so that the user can fix his folders first.
        if len(attachment_folders) != self.file_count:
            raise InputCountException(len(attachment_folders), self.file_count)

        for index, folder in enumerate(attachment_folders):
            command = self.output_commands[index]
            self.__purge_attachments(command)

            for attachment in list_directory(folder):
                file_attachment = FileAttachment(attachment)
                attach_insert_index = len(command) - 2
                command[attach_insert_index:attach_insert_index] = file_attachment.command_list(
                )

    def mux(self):
        """ Execute all output commands and mux the files """
        for command in self.output_commands:
            subprocess.call(["mkvmerge", *command])
